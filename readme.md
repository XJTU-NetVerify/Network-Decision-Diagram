# A library for Network Decision Diagram

This is a prototype implementation of the following [paper]():

> Zechun Li, Peng Zhang, Yichi Zhang, and Hongkun Yang. "NDD: A Decision Diagram for Network Verification", NSDI 2025

## Introduction

**Network Decision Diagram (NDD)** is a new decision diagram customized for network verification. It is more efficient than BDD when used for network verification, in terms of memory and computation. NDD wraps BDD with another layers of decision diagram, such that each node represents a **field** of the network, and each edge is labeled with a BDD encoding the values of that field. Due to the **locality** of fields in networks, NDD can significantly reduce the redundant nodes. 

As an example, the figure below shows three BDDs in (a), and three equivalent NDDs in (c), each edge of which is labelled by per-field BDDs in (b).

![fig4 drawio](https://github.com/user-attachments/assets/daf42009-e201-4c24-8878-99b03ba50a22)

**Atomized Network Decision Diagram (Atomized NDD)** is an extension of NDD, which offers a native support for equivalence classes, a key technique underlying most network verifiers.
In atomized NDD, the label of each edge is a set of atoms, instead of a BDD as in standard NDD.
Using atomized NDD, network verifiers do not need to implement their own algorithms for computing and updating equivalence classes.

<!--
### Definitions

**Definition 1.** A **Network Decision Diagram (NDD)** is a rooted, directed acyclic graph with:

- two terminal nodes ***true*** and ***false***, with an out-degree of zero.

- a set of non-terminal nodes. Each node u is associated with a variable var(u) representing a field of one or multiple bits, and has a set of outgoing edges, denoted as edges(u). Each e $\in$ edges(u) points to a successor of u, denoted as next(e), and has a predicate over the variable var(u), denoted as label(e).

- $\forall u, \forall x, y \in edges(u)$ with $x \ne y$: $label(x)\wedge label(y) = false$, and $\bigvee_{e \in edges(u)}label(e) = true$.

**Todo: add a figure of redundancy in NDD.**

**Definition 2.** A NDD is said to be an **Ordered (ONDD)** if the field variables follow a fixed variable order
(say $f_1 < f_2 < ...,< f_n$ where $f_i < f_j$ means variable $f_i$ appears before variable $f_j$) on all paths through the graph. An ONDD is said to be a **Reduced (RONDD)** if it satisfies the following three conditions:
- Uniqueness: no two distinct nodes represent the same variable and have the same successors;
- No redundant node: no non-terminal node has only edge e with $label(e) = true$;
- No redundant edges: no two edges from the same node point to the same successor, i.e., $\forall u,\forall x, y \in edge(u) : next(x) = next(y) \Rightarrow x = y$.

**Definition 3.** Given a set of NDDs $N$ for a set of variables $F$, we say $A(f) = {{a_1}^f,...,{a_k}^f}$ is the set of **atoms** for variable $f \in F$, with respect with $N$ , if it satisfies the following conditions:
- $a_i^f \ne false,\forall i ∈ {1,..., k}$;
- $\vee_{i=1}^k a_i^f = true$;
- $a_i^f∧a_j^f = false$, if $i \ne j$;
- $\forall e \in edges(u)$, $u$ is a node of $N$ $var(u) = f$: there exists a set $atoms(e) \subset A(f)$, s.t., $label(e) = $\bigvee_{a \in atoms(e)}a$;
- $k$ is the minimum number satisfy the above properties.

**Definition 4.** Given a set of NDDs $N$, we say $N^a$ a is the **atomized NDDs** of $N$, if $N^a = N$ , except that for each $e$ of $N^a$: $label(e) \leftarrow atoms(e)$.
-->

## Project Structure

- `/doc` stores an api documentation generated by `javadoc`.
- `/lib` stores the third party jar packages.
    - `jdd-111.jar` is a modified version of [jdd library](https://bitbucket.org/vahidi/jdd), whose source code can be [access](https://github.com/Augists/jdd).
    - `javabdd_1.0b2.tar.gz` is the original version of [javabdd](https://sourceforge.net/projects/javabdd/) (for comparison).
- `/results` stores some experimental results generated by codes in `/src/experiment`.
- `/src` stores source code.

## Getting Started

Download the NDD package to `/lib/ndd-1.0.jar` and add `<dependency>` in `pom.xml`

```xml
<dependencies>
    <dependency>
        <groupId>org.ants</groupId>
        <artifactId>ndd</artifactId>
        <version>1.0</version>
        <scope>system</scope>
        <systemPath>${project.basedir}/lib/ndd-1.0.jar</systemPath>
    </dependency>
</dependencies>
```

### JNDD

init NDD library
```java
NDD.initNDD(NDD_TABLE_SIZE, 10000, 10000);
```

declare ndd fields
```java
for (int i = 0; i < n; i++) {
    NDD.declareField(n);
}
```

ndd logical operation
```java
NDD[] orBatch = new NDD[n];
for (int i = 0; i < n; i++) {
    NDD condition = NDD.getFalse();
    for (int j = 0; j < n; j++) {
        condition = NDD.orTo(condition, NDD.getVar(i, j));
    }
    orBatch[i] = condition;
}
```

### JavaNDD

For some differences between NDD and BDD, you cannot directly use NDD with only factory changed. Here are the steps showing how to run your project with JavaBDD(NDD).

1. Prepare the parameters for node table size and cache size, also the cache ratio in NDD.

```java
int BDD_NODE_TABLE_SIZE;
int BDD_NODE_CACHE_SIZE;
int NDD_NODE_TABLE_SIZE;
int NDD_NODE_CACHE_RATIO;  // default 8
```

2. Create the `NDDFactory` with BDD parameters. If you are changing your project from JavaBDD, here you can refer to this demo in [Batfish](https://github.com/batfish/batfish)

```java
public class BDDPacket {
    public static BDDFactory defaultFactory(BiFunction<Integer, Integer, BDDFactory> init) {
        BDDFactory factory =
            init.apply(BDD_NODE_TABLE_SIZE, BDD_NODE_CACHE_SIZE);
        factory.setCacheRatio(NDD_NODE_CACHE_RATIO);
        return factory;
    }
    
    public BDDPacket() {
        this(defaultFactory(NDDFactory::init));
    }
    
    public BDDPacket(BDDFactory factory) {
        _factory = factory;
        // ...
    }
}
```

or you can directly pass `NDD` parameters to `Factory` so that do not need to dynamically `setVarNum` (step 3) by

```java
BDDFactory factory = init.apply(numNeeded, NDD_NODE_TABLE_SIZE, BDD_NODE_TABLE_SIZE, BDD_NODE_CACHE_SIZE);
```

which is recommended. It is desirable to define the division of each domain at the beginning, and it is better not to grow the domain dynamically.
`setVarNum(int)` will create a new field with `int` length and add up to the `fieldNum` immediately. (supported but not recommended)

3. (ignore if pass NDD parameters in step 2) NDD cannot grow up dynamically for its fields in every domain should already be computed and passed. So we use a brand new `setVarNum` method.

```java
public BDDPacket(BDDFactory factory) {
    _factory = factory;
    int[] numNeeded = {
      IP_LENGTH, // primed/unprimed src/dst
            IP_LENGTH,
            IP_LENGTH,
            IP_LENGTH,
      PORT_LENGTH, // primed/unprimed src/dst
            PORT_LENGTH,
            PORT_LENGTH,
            PORT_LENGTH,
      IP_PROTOCOL_LENGTH,
      ICMP_CODE_LENGTH,
      ICMP_TYPE_LENGTH,
      TCP_FLAG_LENGTH,
            TCP_FLAG_LENGTH,
            TCP_FLAG_LENGTH,
            TCP_FLAG_LENGTH,
            TCP_FLAG_LENGTH,
            TCP_FLAG_LENGTH,
            TCP_FLAG_LENGTH,
            TCP_FLAG_LENGTH,
      PACKET_LENGTH_LENGTH
    };
    ((NDDFactory) _factory).setVarNum(numNeeded, NDD_NODE_TABLE_SIZE);
}
```

The array `numNeeded` passes every length of field to `NDDFactory` so that it can `declare` these 20 domains in total. To make a better reusage of BDD edges in NDD, each `IP` `PORT` and `TCP_FLAG` are separated.

4. Get every NDD node with `ithVar`. Notice that each NDD node presents one domain, with plenty of `XX_LENGTH` length BDD nodes on its edges.

> It is our first time to get access to the APIs in `JavaBDD`. If some are misunderstood, please contact us or Pull Request if you can. Your contribution to **N**etwork **D**ecision **D**iagram is much appreciated.

## Benchmark

Benchmark (time `second`) on **NQueens**

| N | BDD (JDD) | BDD (JavaBDD - JFactory) | NDD (JNDD) |
| - | --------- | ------------- | -------------------- |
| 6 | 0.017 | 0.056 | 0.012 |
| 7 | 0.023 | 0.072 | 0.019 |
| 8 | 0.04  | 0.109 | 0.038 |
| 9 | 0.223 | 0.28 | 0.176 |
| 10 | 0.615 | 0.913 | 0.344 |
| 11 | 2.567 | 4.424 | 2.257 |
| 12 | 19.109 | 33.024 | 12.417 |

> JavaNDD is implemented using JNDD

## Bibtex

```bibtex
@inproceedings {NDD,
  author = {Zechun Li, Peng Zhang, Yichi Zhang, Hongkun Yang},
  title = {{NDD}: A Decision Diagram for Network Verification},
  booktitle = {22th USENIX Symposium on Networked Systems Design and Implementation (NSDI 25)},
  year = {2025},
  isbn = {},
  address = {},
  pages = {},
  url = {https://www.usenix.org/conference/nsdi25/presentation},
  publisher = {USENIX Association},
  month = apr
}
```

### Contact

- Zechun Li (1467874668@qq.com)
- Peng Zhang (p-zhang@xjtu.edu.cn)
- Yichi Zhang (augists@outlook.com)
- Hongkun Yang (hkyang@google.com)

## License

Apache-2.0 License, see [LICENSE](LICENSE).
